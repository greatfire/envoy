 components/cronet/url_request_context_config.cc | 58 +++++++++++++++++++++++++
 components/cronet/url_request_context_config.h  |  1 +
 net/ssl/ssl_config_service_defaults.cc          |  4 ++
 net/ssl/ssl_config_service_defaults.h           |  2 +
 4 files changed, 65 insertions(+)

diff --git a/components/cronet/url_request_context_config.cc b/components/cronet/url_request_context_config.cc
index 2e55b1ac68c38..3314fc8613772 100644
--- a/components/cronet/url_request_context_config.cc
+++ b/components/cronet/url_request_context_config.cc
@@ -37,6 +37,9 @@
 #include "net/nqe/network_quality_estimator_params.h"
 #include "net/quic/set_quic_flag.h"
 #include "net/socket/ssl_client_socket.h"
+#include "net/ssl/ssl_cipher_suite_names.h"
+#include "net/ssl/ssl_config.h"
+#include "net/ssl/ssl_config_service_defaults.h"
 #include "net/ssl/ssl_key_logger_impl.h"
 #include "net/third_party/quiche/src/quiche/quic/core/crypto/crypto_protocol.h"
 #include "net/third_party/quiche/src/quiche/quic/core/quic_packets.h"
@@ -214,6 +217,9 @@ const char kSpdyGoAwayOnIpChange[] = "spdy_go_away_on_ip_change";
 // DNS options
 const char kResolverRules[] = "resolver_rules";
 
+// cipher suite/ssl version options
+const char kSslConfig[] = "ssl_config";
+
 // Whether the connection status of all bidirectional streams (created through
 // the Cronet engine) should be monitored.
 // The value must be an integer (> 0) and will be interpreted as a suggestion
@@ -780,6 +786,58 @@ void URLRequestContextConfig::SetContextBuilderExperimentalOptions(
       }
       std::string temp_resolver_rules = iter->second.GetString();
       context_builder->set_resolver_rules(temp_resolver_rules);
+    } else if (iter->first == kSslConfig) {
+      if (!iter->second.is_dict()) {
+        LOG(ERROR) << "\"" << iter->first << "\" config params \""
+                   << iter->second << "\" is not a dict value";
+        effective_experimental_options.Remove(iter->first);
+        continue;
+      }
+
+      // decode ssl config
+      // there's a fromDict(), but dict types may not be compatible?
+
+      // part of dict is delimited string, need to transfer values manually?
+      const base::Value::Dict& ssl_config = iter->second.GetDict();
+      const std::string* dict_disabled_cipher_suites = ssl_config.FindString("disabled_cipher_suites");
+      std::optional<int> dict_min_ssl_version = ssl_config.FindInt("min_ssl_version");
+      std::optional<int> dict_max_ssl_version = ssl_config.FindInt("max_ssl_version");
+
+      net::SSLContextConfig ssl_context_config;
+      std::string temp_disabled_cipher_suites = *dict_disabled_cipher_suites;
+      if (!temp_disabled_cipher_suites.empty()) {
+        auto cipher_strings = base::SplitString(temp_disabled_cipher_suites, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
+        // see net::ParseCipherSuites(cipher_strings);
+        std::vector<uint16_t> cipher_suites;
+        cipher_suites.reserve(cipher_strings.size());
+
+        for (auto it = cipher_strings.begin(); it != cipher_strings.end(); ++it) {
+          uint16_t cipher_suite = 0;
+          if (!net::ParseSSLCipherString(*it, &cipher_suite)) {
+            continue;
+          }
+          cipher_suites.push_back(cipher_suite);
+        }
+        std::sort(cipher_suites.begin(), cipher_suites.end());
+
+        ssl_context_config.disabled_cipher_suites =  cipher_suites;
+      }
+
+      if (dict_min_ssl_version.has_value()) {
+        int temp_min_ssl_version = dict_min_ssl_version.value();
+        if (temp_min_ssl_version >= 0 && temp_min_ssl_version <= UINT16_MAX) {
+          ssl_context_config.version_min = static_cast<uint16_t>(temp_min_ssl_version);
+        }
+      }
+      if (dict_max_ssl_version.has_value()) {
+        int temp_max_ssl_version = dict_max_ssl_version.value();
+        if (temp_max_ssl_version >= 0 && temp_max_ssl_version <= UINT16_MAX) {
+          ssl_context_config.version_max = static_cast<uint16_t>(temp_max_ssl_version);
+        }
+      }
+
+      auto ssl_config_service_ptr = std::make_unique<net::SSLConfigServiceDefaults>(ssl_context_config);
+      context_builder->set_ssl_config_service(std::move(ssl_config_service_ptr));
     } else {
       LOG(WARNING) << "Unrecognized Cronet experimental option \""
                    << iter->first << "\" with params \"" << iter->second;
diff --git a/components/cronet/url_request_context_config.h b/components/cronet/url_request_context_config.h
index fe91814bd3df6..493bf0d7af28d 100644
--- a/components/cronet/url_request_context_config.h
+++ b/components/cronet/url_request_context_config.h
@@ -17,6 +17,7 @@
 #include "net/base/network_handle.h"
 #include "net/cert/cert_verifier.h"
 #include "net/nqe/effective_connection_type.h"
+#include "net/ssl/ssl_config.h"
 #include "url/origin.h"
 
 namespace net {
diff --git a/net/ssl/ssl_config_service_defaults.cc b/net/ssl/ssl_config_service_defaults.cc
index 7d137e59662d3..440ff49d0aba0 100644
--- a/net/ssl/ssl_config_service_defaults.cc
+++ b/net/ssl/ssl_config_service_defaults.cc
@@ -9,6 +9,10 @@ namespace net {
 SSLConfigServiceDefaults::SSLConfigServiceDefaults() = default;
 SSLConfigServiceDefaults::~SSLConfigServiceDefaults() = default;
 
+SSLConfigServiceDefaults::SSLConfigServiceDefaults(SSLContextConfig default_config): default_config_(default_config) {
+  // initialize with default config parameter
+}
+
 SSLContextConfig SSLConfigServiceDefaults::GetSSLContextConfig() {
   return default_config_;
 }
diff --git a/net/ssl/ssl_config_service_defaults.h b/net/ssl/ssl_config_service_defaults.h
index 32770a45d4f24..d6c7dde1d1a03 100644
--- a/net/ssl/ssl_config_service_defaults.h
+++ b/net/ssl/ssl_config_service_defaults.h
@@ -24,6 +24,8 @@ class NET_EXPORT SSLConfigServiceDefaults : public SSLConfigService {
 
   ~SSLConfigServiceDefaults() override;
 
+  SSLConfigServiceDefaults(SSLContextConfig default_config);
+
   // Returns the default SSL config settings.
   SSLContextConfig GetSSLContextConfig() override;
 
